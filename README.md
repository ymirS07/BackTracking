# BackTracking

回溯是递归的副产品，只要有递归就会有回溯。</br>
因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案。</br>

## 回溯法解决的问题
- 组合问题：N个数里面按一定规则找出k个数的集合</br>
- 排列问题：N个数按一定规则全排列，有几种排列方式</br>
- 切割问题：一个字符串按一定规则有几种切割方式</br>
- 子集问题：一个N个数的集合里有多少符合条件的子集</br>
- 棋盘问题：N皇后，解数独等等

## 回溯法的一般思路
回溯法解决的问题都可以抽象为**树形结构**：集合的大小就构成了树的宽度，递归的深度就构成了树的深度。<br/>
众所周知，遍历树形结构一定要有**终止条件**，所以回溯也有要终止条件。什么时候达到了终止条件？一般来说搜到**叶子节点**了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。

首先，我们定义两个全局变量，二维数组result存放结果集，数组path存放符合条件的结果。</br>
然后，写出递归的临界条件，也就是上面所说的终止条件，注意，这里只是在这一个分支上终止了。</br>
接着，for循环，也就是遍历集合区间，可以理解**一个节点有多少个孩子**，这个for循环就执行多少次。
最后，所谓的回溯，也就是从这一层回到上一层。

剪枝：把整个回溯过程抽象为一棵树形结构，然后可以直观的看出，剪枝究竟是剪的哪里。
